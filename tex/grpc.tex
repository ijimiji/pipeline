\section{gRPC в разработке микросервисов}

Как уже было упомянуто в предыдущем пункте, обмен данными между микросервисами имеет большое значение при проектировании распределенных систем. При правильном проектировании микросервисы сохранят свою
автономность, в то же время необходимо вносить в них изменения и выпускать их новые версии независимо от остальных частей системы. При некорректном исполнении система будет функционировать со сбоями и низкой производительностью, что недопустимо при построении микросервисной архитектуры.

Для определения способа взаимодействия одного микросервиса с другим имеется
выбор между текстовыми форматами данных, как JSON, XML, SOAP и т.д, и бинарными форматами данных такими, как Protocol Buffers, Flatbuffers, 
Cap'n Proto и Simple Binary Encoding. 

При выборе формата передачи данных обычно руководствуются скоростью сериализации и десериализации, простотой использования и поддержкой со стороны сообщества и разработчиков.

Текстовые форматы данных обычно лучше всего поддержаны инструментами разработки и не требуют дополнительных усилий по внедрению их в API сервисов, однако они значительно проигрывают в скорости передачи данных и не предоставляют возможности версионирования без runtime проверок схемы данных, что несет еще большие накладные расходы при конвертации данных, несмотря на то, что за время своего существования парсеры для данных форматов, в частности JSON и XML, были сильно оптимизированы и поддержаны виртуальными машинами многих языков. Поэтому при выборе формата данных для коммуникации микросервисов обычно выбирают бинарные форматы с возможностью версионирования и строгой схемой \cite{Bolanowski_2022}.

Вышеупомянутые Cap'n Proto, SBE и Flatbuffers демонстрируют хорошую производительность в синтетических тестах, однако не обладают поддержкой широкого списка языков программирования и инструментов для разработки \cite{comp}. Protocol Buffers же предлагает разумный компромисс между производительностью и простотой использования, поэтому в настоящий момент является самым популярным вариантом при разработке микросервисов \cite{protobuf}.

Для написания Protobuf файлов используют язык описания интерфейсов (IDL).
Например, чтобы описать структуру данных сообщения, нужно добавить message, имя структуры, а внутри тип, название и номер поля. Номера полей нужны для обратной совместимости, поэтому не стоит менять их последовательность при добавлении или удалении полей. Образец сообщения представлен в листинге \ref{lst:proto}.
\begin{lstlisting}[caption={Сетевые хендлеры, осуществляющие основую логику},label=lst:proto,captionpos=b] 
syntax = "proto3";
package user;

service User {
  rpc GetUser(GetUserRequest) returns (UserInfo) {}
  rpc CreateUser(UserInfo) returns (UserStatus) {}
}

message UserInfo {
  string email = 2;
  string name = 3;
  repeated string phone = 4;

  message Address {
    string street = 1;
    string city = 2;
    string state = 3;
    string zip = 4;
  }

  Address address = 5;
}

message GetUserRequest {
  string email = 1;
}

message UserStatus {
  string error = 1;
}
\end{lstlisting}


В Protocol Buffers данные представлены и передаются в
бинарном формате, что существенно уменьшает время сериализации/десериализации
данных. Также с применением механизма Protocol Buffers размер передаваемых данных в разы меньше \cite{Bolanowski_2022}.

В настоящее время наиболее популярным RPC-решением для интеграции
микросервисов является gRPC, который по умолчанию использует Protocol Buffers для кодирования сообщений. Это высокопроизводительный фреймворк, разработанный компанией Google для вызовов удаленных процедур, работающий поверх протокола
HTTP/2. Как и во многих RPC-системах, gRPC основан на идее определения сервиса,
указывающий методы, которые можно вызвать удаленно с их параметрами и
возвращаемыми типами \cite{grpc}.

На стороне сервера реализуются методы, которые предоставляются для клиентов, и
запускается gRPC-сервер для обработки клиентских запросов. На стороне клиента
используется заглушка, которая предоставляет те же методы, что и сервер. Его высокая производительность достигается за счет использования протокола HTTP/2 и Protocol Buffers.

Однако у gRPC есть ряд недостатков, которые стоит учитывать при проектировании систем с применением данной технологии. Во-первых, Protocol Buffers это бинарный формат, поэтому для отладки и разработки приложений требуется иметь актуальную версию схемы данных, что делает невозможным отправку с клиента произвольных запросов и затрудняет отладки вне слоя приложения, где данные не представлены человекочитаемым форматом. Во-вторых, несмотря на то, что в 2022 была представлена спецификация протокола HTTP/3, HTTP/2 все еще имеет ограниченную поддержку со стороны браузеров, что делает невозможным непосредственную коммуникацию между веб-клиентом и сервисами. 

Частично это проблема решается специальными расширениями, которые добавляют HTTP-прокси слой, который проксирует HTTP/1 запросы с небинарным форматом данных, например, JSON, в HTTP/2 запросы с данными в формате Protocol Buffers, однако это нивелирует достоинства бинарной сериализации из-за необходимости дополнительной конвертации данных между форматами.

Поэтому при проектировке систем общеиспользуемый REST API интерфейс присутствует лишь во внешнем слое приложения и может быть реализован без расширений, исходя из конкретной бизнес-логики, что добавляет накладные расходы на цикл сериализации и десериализации лишь во входном и выходном запросах.